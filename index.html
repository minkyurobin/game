<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïò§Î™© Í≤åÏûÑ (3Ïù∏Ïö©, 19x19)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #333;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .start-container {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            width: 90%;
        }

        .game-logo {
            font-size: 2em;
            color: #2c5282;
            margin-bottom: 10px;
        }

        .time-select, .mode-select, .skill-mode-select, .human-players-select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 2px solid #2c5282;
            border-radius: 6px;
            margin: 8px 0;
            background: #fff;
        }

        .start-btn {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .game-container {
            margin-top: 20px;
            text-align: center;
            max-width: 600px;
            width: 100%;
            padding: 10px;
            display: none;
        }

        .turn-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #2c5282;
        }

        .turn-info span {
            font-weight: 700;
            color: #e74c3c;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .button-container {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .restart-btn, .skill-btn, .egg-skill-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .restart-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .skill-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .egg-skill-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .restart-btn:hover, .skill-btn:hover, .egg-skill-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .skill-btn:disabled, .egg-skill-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-log {
            background: #fff;
            border: 2px solid #2c5282;
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            border-left: 2px solid;
        }

        .log-success { border-left-color: #27ae60; color: #27ae60; }
        .log-error { border-left-color: #e74c3c; color: #e74c3c; }
        .log-info { border-left-color: #2c5282; color: #2c5282; }
        .log-warning { border-left-color: #f39c12; color: #f39c12; }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            width: 90%;
            text-align: center;
        }

        .modal-content h2 {
            color: #2c5282;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .modal-content button {
            padding: 8px 12px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            margin: 5px;
        }

        .modal-content button:hover {
            background: linear-gradient(45deg, #3b82f6, #2c5282);
        }

        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }
            .start-container {
                padding: 15px;
                max-width: 280px;
            }
            .game-logo {
                font-size: 1.6em;
            }
            .modal-content {
                max-width: 250px;
            }
            .game-log {
                max-height: 100px;
            }
            .button-container {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="start-screen" id="start-screen">
        <div class="start-container">
            <div class="game-logo">‚ö´‚ö™‚óÜ Ïò§Î™© Í≤åÏûÑ (19x19)</div>
            <select class="mode-select" id="game-mode" aria-label="Í≤åÏûÑ Î™®Îìú ÏÑ†ÌÉù">
                <option value="three-player">3Ïù∏Ïö©</option>
                <option value="vs-computer">Ïª¥Ìì®ÌÑ∞ ÎåÄÍ≤∞</option>
                <option value="two-player">2Ïù∏Ïö©</option>
            </select>
            <select class="human-players-select" id="human-players" aria-label="Ïù∏Í∞Ñ ÌîåÎ†àÏù¥Ïñ¥ Ïàò ÏÑ†ÌÉù" style="display: none;">
                <option value="1">1Î™Ö (Ìùë vs Î∞± Ïª¥Ìì®ÌÑ∞ vs Ï≤≠ Ïª¥Ìì®ÌÑ∞)</option>
                <option value="2">2Î™Ö (Ìùë vs Î∞± vs Ï≤≠ Ïª¥Ìì®ÌÑ∞)</option>
            </select>
            <select class="skill-mode-select" id="skill-mode" aria-label="Ïä§ÌÇ¨ Î™®Îìú ÏÑ†ÌÉù">
                <option value="with-skills">Ïä§ÌÇ¨ Ìè¨Ìï®</option>
                <option value="no-skills">Ïä§ÌÇ¨ ÎØ∏Ìè¨Ìï®</option>
            </select>
            <select class="time-select" id="time-limit" aria-label="ÏãúÍ∞Ñ Ï†úÌïú ÏÑ†ÌÉù">
                <option value="10000">10Ï¥à</option>
                <option value="30000">30Ï¥à</option>
                <option value="60000">1Î∂Ñ</option>
            </select>
            <button class="start-btn" onclick="startGame()" aria-label="Í≤åÏûÑ ÏãúÏûë">Í≤åÏûÑ ÏãúÏûë</button>
        </div>
    </div>

    <div class="game-container" id="game-container">
        <div class="turn-info" id="turn-info">ÌÑ¥: <span>Ìùë</span> (‚óè ÌùëÎèå)</div>
        <canvas id="game-board" width="570" height="570"></canvas>
        <div class="button-container">
            <button class="restart-btn" onclick="restartGame()" aria-label="Îã§Ïãú ÏãúÏûë">Îã§Ïãú ÏãúÏûë</button>
            <button class="skill-btn" id="skill-btn" onclick="useMeteorStrike()" aria-label="Ïö¥ÏÑù ÎÇôÌïò">Ïö¥ÏÑù ÎÇôÌïò (2)</button>
            <button class="egg-skill-btn" id="egg-skill-btn" onclick="toggleEggSkillMode()" aria-label="ÏïåÍπåÍ∏∞">ÏïåÍπåÍ∏∞ (3)</button>
        </div>
        <div class="game-log" id="game-log">
            <div class="log-entry log-info">üéâ Ïò§Î™© Í≤åÏûÑ ÏãúÏûë!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const boardSize = 19;
        const cellSize = 30;
        let board = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); // 0: ÎπàÏπ∏, 1: ÌùëÎèå, 2: Î∞±Îèå, 3: Ï≤≠Îèå
        let currentPlayer = 1; // 1: ÌùëÎèå, 2: Î∞±Îèå, 3: Ï≤≠Îèå
        let player1Name = 'Ìùë';
        let player2Name = 'Î∞±';
        let player3Name = 'Ï≤≠';
        let isComputerMode = false;
        let isThreePlayerMode = false;
        let humanPlayers = 3;
        let computerPlayers = [];
        let isSkillMode = true;
        let gameActive = false;
        let timeLimit = 10000;
        let timerId = null;
        let timeLeft = 0;
        let logs = [];
        let moveCount = 0;
        let player1MeteorSkill = 2;
        let player2MeteorSkill = 2;
        let player3MeteorSkill = 2;
        let player1EggSkill = 3;
        let player2EggSkill = 3;
        let player3EggSkill = 3;
        let isEggSkillMode = false;
        let selectedRow = -1;
        let selectedCol = -1;
        let animationFrameId = null;

        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded: Initializing game');
            drawBoard();
            updateSkillButton();
            updateEggSkillButton();
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('game-mode').addEventListener('change', updateHumanPlayersSelect);
        });

        function updateHumanPlayersSelect() {
            const gameMode = document.getElementById('game-mode').value;
            const humanPlayersSelect = document.getElementById('human-players');
            humanPlayersSelect.style.display = gameMode === 'vs-computer' ? 'block' : 'none';
        }

        function startGame() {
            timeLimit = parseInt(document.getElementById('time-limit').value);
            const gameMode = document.getElementById('game-mode').value;
            isSkillMode = document.getElementById('skill-mode').value === 'with-skills';
            isThreePlayerMode = gameMode === 'three-player';
            isComputerMode = gameMode === 'vs-computer';
            humanPlayers = isComputerMode ? parseInt(document.getElementById('human-players').value) : (gameMode === 'two-player' ? 2 : 3);
            computerPlayers = [];
            if (isComputerMode) {
                if (humanPlayers === 1) computerPlayers = [2, 3]; // Î∞±, Ï≤≠ Ïª¥Ìì®ÌÑ∞
                else if (humanPlayers === 2) computerPlayers = [3]; // Ï≤≠ Ïª¥Ìì®ÌÑ∞
            } else if (gameMode === 'two-player') {
                player3Name = null; // 2Ïù∏Ïö© Î™®ÎìúÏóêÏÑúÎäî Ï≤≠ ÌîåÎ†àÏù¥Ïñ¥ Ï†úÏô∏
            }

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = isSkillMode ? 2 : 0;
            player2MeteorSkill = isSkillMode ? 2 : 0;
            player3MeteorSkill = isSkillMode && player3Name ? 2 : 0;
            player1EggSkill = isSkillMode ? 3 : 0;
            player2EggSkill = isSkillMode && !computerPlayers.includes(2) ? 3 : 0;
            player3EggSkill = isSkillMode && !computerPlayers.includes(3) && player3Name ? 3 : 0;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            currentPlayer = 1;
            logs = [];
            log('üéâ Í≤åÏûÑ ÏãúÏûë!', 'info');
            drawBoard();
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
            console.log('Game started: Mode:', gameMode, 'Human players:', humanPlayers, 'Computer players:', computerPlayers, 'Skill mode:', isSkillMode);
            if (computerPlayers.includes(currentPlayer)) {
                setTimeout(computerMove, 500);
            }
        }

        function drawBoard() {
            console.log('Drawing board');
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            const hue = (Date.now() / 1000) % 360;
            gradient.addColorStop(0, `hsl(${hue}, 80%, 50%)`);
            gradient.addColorStop(0.2, `hsl(${hue + 60}, 80%, 50%)`);
            gradient.addColorStop(0.4, `hsl(${hue + 120}, 80%, 50%)`);
            gradient.addColorStop(0.6, `hsl(${hue + 180}, 80%, 50%)`);
            gradient.addColorStop(0.8, `hsl(${hue + 240}, 80%, 50%)`);
            gradient.addColorStop(1, `hsl(${hue + 300}, 80%, 50%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const fullness = timeLeft / (timeLimit / 1000);
            const baseHue = 240;
            const targetHue = 0;
            const boardHue = baseHue - (baseHue - targetHue) * (1 - fullness);
            ctx.fillStyle = `hsl(${boardHue}, 50%, 70%)`;
            ctx.fillRect(cellSize / 2, cellSize / 2, canvas.width - cellSize, canvas.height - cellSize);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize / 2 + i * cellSize, cellSize / 2);
                ctx.lineTo(cellSize / 2 + i * cellSize, canvas.height - cellSize / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.lineTo(canvas.width - cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.stroke();
            }

            ctx.font = '24px Roboto';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            textGradient.addColorStop(0, `hsl(${hue + 30}, 80%, 50%)`);
            textGradient.addColorStop(0.5, `hsl(${hue + 90}, 80%, 50%)`);
            textGradient.addColorStop(1, `hsl(${hue + 150}, 80%, 50%)`);
            ctx.fillStyle = textGradient;
            ctx.fillText(`ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${timeLeft}Ï¥à`, canvas.width / 2, 20);

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 1) {
                        ctx.fillStyle = '#000';
                        drawStone(row, col, 1.0, 'circle');
                    } else if (board[row][col] === 2) {
                        ctx.fillStyle = '#fff';
                        drawStone(row, col, 1.0, 'circle');
                    } else if (board[row][col] === 3) {
                        ctx.fillStyle = '#00f';
                        drawStone(row, col, 1.0, 'diamond');
                    }
                }
            }
        }

        function drawStone(row, col, opacity = 1.0, shape = 'circle') {
            ctx.globalAlpha = opacity;
            ctx.beginPath();
            const x = cellSize / 2 + col * cellSize;
            const y = cellSize / 2 + row * cellSize;
            const r = cellSize / 2 - 2;
            if (shape === 'circle') {
                ctx.arc(x, y, r, 0, Math.PI * 2);
            } else if (shape === 'diamond') {
                ctx.moveTo(x, y - r);
                ctx.lineTo(x + r, y);
                ctx.lineTo(x, y + r);
                ctx.lineTo(x - r, y);
                ctx.closePath();
            }
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            if (isEggSkillMode || computerPlayers.includes(currentPlayer)) return;
            timeLeft = timeLimit / 1000;
            drawBoard();
            timerId = setInterval(() => {
                timeLeft--;
                drawBoard();
                if (timeLeft <= 0) {
                    clearInterval(timerId);
                    const loser = currentPlayer === 1 ? player1Name : currentPlayer === 2 ? player2Name : player3Name;
                    const winner = currentPlayer === 1 ? (Math.random() < 0.5 ? player2Name : player3Name) : 
                                   currentPlayer === 2 ? (Math.random() < 0.5 ? player1Name : player3Name) : 
                                   (Math.random() < 0.5 ? player1Name : player2Name);
                    log(`${loser}Îãò ÏãúÍ∞Ñ Ï¥àÍ≥º Ìå®Î∞∞!`, 'error');
                    showModal(`${winner}Îãò ÏãúÍ∞ÑÌå® ÏäπÎ¶¨!`, 'success', true);
                    gameActive = false;
                }
            }, 1000);
        }

        function addStonesFor30Moves() {
            if (moveCount % 30 !== 0 || !gameActive) return;
            const emptyCells = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 0) emptyCells.push({ row, col });
                }
            }
            if (emptyCells.length < 9) {
                log('‚ö† ÎπàÏπ∏ Î∂ÄÏ°±ÏúºÎ°ú Îèå Ï∂îÍ∞Ä Î∂àÍ∞Ä!', 'warning');
                return;
            }

            for (let player = 1; player <= (player3Name ? 3 : 2); player++) {
                for (let i = 0; i < 3; i++) {
                    if (emptyCells.length === 0) break;
                    const randomIndex = Math.floor(Math.random() * emptyCells.length);
                    const { row, col } = emptyCells[randomIndex];
                    board[row][col] = player;
                    emptyCells.splice(randomIndex, 1);
                    const playerName = player === 1 ? player1Name : player === 2 ? player2Name : player3Name;
                    log(`üéØ ${moveCount}Ïàò ÎèÑÎã¨! ${playerName} Îèå (${row + 1}, ${col + 1}) Ï∂îÍ∞Ä`, 'info');
                }
            }

            drawBoard();
            log(`üéØ ${moveCount}Ïàò ÎèÑÎã¨! Í∞Å ÌîåÎ†àÏù¥Ïñ¥ 3Í∞ú Îèå Ï∂îÍ∞Ä`, 'warning');

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] !== 0 && checkWin(row, col)) {
                        const winner = board[row][col] === 1 ? player1Name : board[row][col] === 2 ? player2Name : player3Name;
                        showModal(`${winner}Îãò ÏäπÎ¶¨!`, 'success', true);
                        clearInterval(timerId);
                        gameActive = false;
                        return;
                    }
                }
            }
        }

        function removeRandomOpponentStone() {
            if (moveCount < 2) return;
            const opponents = [1, 2, 3].filter(p => p !== currentPlayer && (player3Name || p !== 3));
            if (opponents.length === 0) return;
            const opponent = opponents[Math.floor(Math.random() * opponents.length)];
            const opponentStones = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === opponent) {
                        opponentStones.push({ row, col });
                    }
                }
            }
            if (opponentStones.length === 0) {
                log('‚ö° Ï†úÍ±∞Ìï† ÏÉÅÎåÄÎ∞© ÎèåÏù¥ ÏóÜÏäµÎãàÎã§!', 'warning');
                return;
            }
            if (Math.random() < 0.1) {
                const randomIndex = Math.floor(Math.random() * opponentStones.length);
                const { row, col } = opponentStones[randomIndex];
                board[row][col] = 0;
                const opponentName = opponent === 1 ? player1Name : opponent === 2 ? player2Name : player3Name;
                log(`‚ö° ${opponentName}ÎãòÏùò Îèå (${row + 1}, ${col + 1}) Ï†úÍ±∞!`, 'warning');
                drawBoard();
            }
        }

        function evaluateBoard(player) {
            let score = 0;
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            const center = Math.floor(boardSize / 2);

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; row < boardSize; col++) {
                    if (board[row][col] !== player) continue;
                    const distance = Math.abs(row - center) + Math.abs(col - center);
                    score += 5 / (distance + 1);

                    for (const [dr, dc] of directions) {
                        let count = 1;
                        let openEnds = 0;
                        for (let dir = -1; dir <= 1; dir += 2) {
                            for (let i = 1; i <= 4; i++) {
                                const newRow = row + dr * i * dir;
                                const newCol = col + dc * i * dir;
                                if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                                if (board[newRow][newCol] === player) {
                                    count++;
                                } else if (board[newRow][newCol] === 0) {
                                    openEnds++;
                                    break;
                                } else {
                                    break;
                                }
                            }
                        }
                        if (count >= 5) score += 10000;
                        else if (count === 4) score += openEnds === 2 ? 1000 : 500;
                        else if (count === 3) score += openEnds === 2 ? 100 : 50;
                        else if (count === 2) score += openEnds === 2 ? 10 : 5;
                    }
                }
            }

            const opponents = [1, 2, 3].filter(p => p !== player && (player3Name || p !== 3));
            for (const opp of opponents) {
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        if (board[row][col] !== opp) continue;
                        for (const [dr, dc] of directions) {
                            let count = 1;
                            for (let dir = -1; dir <= 1; dir += 2) {
                                for (let i = 1; i <= 4; i++) {
                                    const newRow = row + dr * i * dir;
                                    const newCol = col + dc * i * dir;
                                    if (newRow < 0 || newRow >= boardSize || newCol < 0 || newCol >= boardSize) break;
                                    if (board[newRow][newCol] === opp) {
                                        count++;
                                    } else {
                                        break;
                                    }
                                }
                            }
                            if (count >= 5) score -= 10000;
                            else if (count === 4) score -= 500;
                            else if (count === 3) score -= 50;
                        }
                    }
                }
            }
            return score;
        }

        function minimax(board, depth, alpha, beta, maximizingPlayer, player) {
            if (depth === 0) {
                return { score: evaluateBoard(player) };
            }

            const opponents = [1, 2, 3].filter(p => p !== player && (player3Name || p !== 3));
            let bestMove = null;

            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        if (board[row][col] !== 0) continue;
                        board[row][col] = player;
                        if (checkWin(row, col)) {
                            board[row][col] = 0;
                            return { score: 10000, move: { row, col } };
                        }
                        const evalScore = minimax(board, depth - 1, alpha, beta, false, player).score;
                        board[row][col] = 0;
                        if (evalScore > maxEval) {
                            maxEval = evalScore;
                            bestMove = { row, col };
                        }
                        alpha = Math.max(alpha, evalScore);
                        if (beta <= alpha) break;
                    }
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        if (board[row][col] !== 0) continue;
                        for (const opp of opponents) {
                            board[row][col] = opp;
                            if (checkWin(row, col)) {
                                board[row][col] = 0;
                                return { score: -10000, move: { row, col } };
                            }
                            const evalScore = minimax(board, depth - 1, alpha, beta, true, player).score;
                            board[row][col] = 0;
                            if (evalScore < minEval) {
                                minEval = evalScore;
                                bestMove = { row, col };
                            }
                            beta = Math.min(beta, evalScore);
                            if (beta <= alpha) break;
                        }
                    }
                }
                return { score: minEval, move: bestMove };
            }
        }

        function useMeteorStrike() {
            if (!gameActive || !isSkillMode) return;
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : 
                              currentPlayer === 2 ? player2MeteorSkill : player3MeteorSkill;
            if (skillCount <= 0) {
                const playerName = currentPlayer === 1 ? player1Name : 
                                  currentPlayer === 2 ? player2Name : player3Name;
                showModal(`${playerName}ÎãòÏùÄ Ïö¥ÏÑù Ïä§ÌÇ¨ÏùÑ Î™®Îëê ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§!`, 'error');
                return;
            }

            const emptyCells = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 0) emptyCells.push({ row, col });
                }
            }

            if (emptyCells.length === 0) {
                showModal('ÎπàÏπ∏Ïù¥ ÏóÜÏñ¥ Ïä§ÌÇ¨ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§!', 'error');
                return;
            }

            const stonesToPlace = Math.min(10, emptyCells.length);
            let placed = 0;
            for (let i = 0; i < stonesToPlace; i++) {
                if (emptyCells.length === 0) break;
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                const { row, col } = emptyCells[randomIndex];
                board[row][col] = currentPlayer;
                emptyCells.splice(randomIndex, 1);
                log(`‚òÑ Ïö¥ÏÑù ÎÇôÌïò: (${row + 1}, ${col + 1})Ïóê Îèå Î∞∞Ïπò`, 'info');
                placed++;
            }

            moveCount += placed;
            drawBoard();
            const playerName = currentPlayer === 1 ? player1Name : 
                              currentPlayer === 2 ? player2Name : player3Name;
            log(`‚òÑ ${playerName}ÎãòÏù¥ Ïö¥ÏÑù ÎÇôÌïò Ïä§ÌÇ¨ ÏÇ¨Ïö©!`, 'warning');

            if (currentPlayer === 1) player1MeteorSkill--;
            else if (currentPlayer === 2) player2MeteorSkill--;
            else player3MeteorSkill--;
            updateSkillButton();

            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === currentPlayer && checkWin(row, col)) {
                        const winner = currentPlayer === 1 ? player1Name : 
                                      currentPlayer === 2 ? player2Name : player3Name;
                        showModal(`${winner}Îãò ÏäπÎ¶¨!`, 'success', true);
                        clearInterval(timerId);
                        gameActive = false;
                        return;
                    }
                }
            }

            addStonesFor30Moves();

            currentPlayer = (currentPlayer % (player3Name ? 3 : 2)) + 1;
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
            if (computerPlayers.includes(currentPlayer)) {
                setTimeout(computerMove, 500);
            }
        }

        function toggleEggSkillMode() {
            if (!gameActive || !isSkillMode || computerPlayers.includes(currentPlayer)) return;
            const skillCount = currentPlayer === 1 ? player1EggSkill : 
                              currentPlayer === 2 ? player2EggSkill : player3EggSkill;
            if (skillCount <= 0) {
                showModal('ÏïåÍπåÍ∏∞ Ïä§ÌÇ¨ ÏÇ¨Ïö© ÌöüÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'error');
                return;
            }

            isEggSkillMode = !isEggSkillMode;
            selectedRow = -1;
            selectedCol = -1;
            if (isEggSkillMode) {
                if (timerId) clearInterval(timerId);
                const playerName = currentPlayer === 1 ? player1Name : 
                                  currentPlayer === 2 ? player2Name : player3Name;
                log(`ü™∂ ${playerName}Îãò ÏïåÍπåÍ∏∞ Î™®Îìú ÌôúÏÑ±Ìôî! ÏûêÏã†Ïùò Îèå ÏÑ†ÌÉù`, 'warning');
            } else {
                updateEggSkillButton();
                startTimer();
                if (computerPlayers.includes(currentPlayer)) {
                    setTimeout(computerMove, 500);
                }
            }
            updateEggSkillButton();
        }

        function updateEggSkillButton() {
            const skillBtn = document.getElementById('egg-skill-btn');
            skillBtn.style.display = isSkillMode ? 'inline-block' : 'none';
            if (!isSkillMode) return;
            const skillCount = currentPlayer === 1 ? player1EggSkill : 
                              currentPlayer === 2 ? player2EggSkill : player3EggSkill;
            skillBtn.disabled = (skillCount <= 0 && !isEggSkillMode) || computerPlayers.includes(currentPlayer);
            skillBtn.textContent = isEggSkillMode ? 'ÏïåÍπåÍ∏∞ Ï∑®ÏÜå' : `ÏïåÍπåÍ∏∞ (${skillCount})`;
        }

        function updateSkillButton() {
            const skillBtn = document.getElementById('skill-btn');
            skillBtn.style.display = isSkillMode ? 'inline-block' : 'none';
            if (!isSkillMode) return;
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : 
                              currentPlayer === 2 ? player2MeteorSkill : player3MeteorSkill;
            skillBtn.disabled = skillCount <= 0;
            skillBtn.textContent = `Ïö¥ÏÑù ÎÇôÌïò (${skillCount})`;
        }

        function handleCanvasClick(event) {
            if (!gameActive || computerPlayers.includes(currentPlayer)) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;

            if (isEggSkillMode && isSkillMode) {
                if (board[row][col] !== currentPlayer) return;
                selectedRow = row;
                selectedCol = col;

                const directions = [
                    { dr: 0, dc: 1, name: 'Ïò§Î•∏Ï™Ω' },
                    { dr: 0, dc: -1, name: 'ÏôºÏ™Ω' },
                    { dr: 1, dc: 0, name: 'ÏïÑÎûò' },
                    { dr: -1, dc: 0, name: 'ÏúÑ' },
                    { dr: 1, dc: 1, name: 'Ïö∞Ìïò' },
                    { dr: -1, dc: 1, name: 'Ïö∞ÏÉÅ' },
                    { dr: 1, dc: -1, name: 'Ï¢åÌïò' },
                    { dr: -1, dc: -1, name: 'Ï¢åÏÉÅ' }
                ];
                const { dr, dc, name } = directions[Math.floor(Math.random() * directions.length)];
                log(`ü™∂ ${name} Î∞©Ìñ• ÏÑ†ÌÉù`, 'info');

                const opponents = [1, 2, 3].filter(p => p !== currentPlayer && (player3Name || p !== 3));
                const targetOpponent = opponents[Math.floor(Math.random() * opponents.length)];
                const stonesToRemove = [];
                let r = row;
                let c = col;
                while (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                    if (board[r][c] === targetOpponent) {
                        stonesToRemove.push({ row: r, col: c });
                    }
                    r += dr;
                    c += dc;
                }

                let animationProgress = 0;
                const animationDuration = 500;
                function animate() {
                    drawBoard();
                    const t = animationProgress / animationDuration;
                    const opacity = 1 - t;
                    const moveDistance = t * 5 * cellSize;
                    const moveX = cellSize / 2 + col * cellSize + moveDistance * dc;
                    const moveY = cellSize / 2 + row * cellSize + moveDistance * dr;
                    ctx.fillStyle = currentPlayer === 1 ? '#000' : currentPlayer === 2 ? '#fff' : '#00f';
                    drawStone(row, col, opacity, currentPlayer === 3 ? 'diamond' : 'circle');
                    ctx.beginPath();
                    if (currentPlayer === 3) {
                        ctx.moveTo(moveX, moveY - (cellSize / 2 - 2));
                        ctx.lineTo(moveX + (cellSize / 2 - 2), moveY);
                        ctx.lineTo(moveX, moveY + (cellSize / 2 - 2));
                        ctx.lineTo(moveX - (cellSize / 2 - 2), moveY);
                        ctx.closePath();
                    } else {
                        ctx.arc(moveX, moveY, cellSize / 2 - 2, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    stonesToRemove.forEach(({ row, col }) => {
                        ctx.fillStyle = targetOpponent === 1 ? '#000' : targetOpponent === 2 ? '#fff' : '#00f';
                        drawStone(row, col, opacity, targetOpponent === 3 ? 'diamond' : 'circle');
                    });

                    animationProgress += 16;
                    if (animationProgress < animationDuration) {
                        animationFrameId = requestAnimationFrame(animate);
                    } else {
                        cancelAnimationFrame(animationFrameId);
                        board[row][col] = 0;
                        stonesToRemove.forEach(({ row, col }) => {
                            board[row][col] = 0;
                            const opponentName = targetOpponent === 1 ? player1Name : 
                                                targetOpponent === 2 ? player2Name : player3Name;
                            log(`ü™∂ ${opponentName}ÎãòÏùò Îèå (${row + 1}, ${col + 1}) Ï†úÍ±∞!`, 'warning');
                        });
                        drawBoard();
                        const playerName = currentPlayer === 1 ? player1Name : 
                                          currentPlayer === 2 ? player2Name : player3Name;
                        log(`ü™∂ ${playerName}ÎãòÏù¥ ÏïåÍπåÍ∏∞ Ïä§ÌÇ¨ ÏÇ¨Ïö©!`, 'warning');
                        if (currentPlayer === 1) player1EggSkill--;
                        else if (currentPlayer === 2) player2EggSkill--;
                        else player3EggSkill--;
                        moveCount++;
                        isEggSkillMode = false;
                        updateEggSkillButton();
                        addStonesFor30Moves();
                        currentPlayer = (currentPlayer % (player3Name ? 3 : 2)) + 1;
                        updateTurnInfo();
                        updateSkillButton();
                        startTimer();
                        if (computerPlayers.includes(currentPlayer)) {
                            setTimeout(computerMove, 500);
                        }
                    }
                }
                animationFrameId = requestAnimationFrame(animate);
            } else {
                if (board[row][col] !== 0) return;
                board[row][col] = currentPlayer;
                moveCount++;
                drawBoard();
                const playerName = currentPlayer === 1 ? player1Name : 
                                  currentPlayer === 2 ? player2Name : player3Name;
                log(`${playerName}ÎãòÏù¥ (${row + 1}, ${col + 1})Ïóê Îèå Î∞∞Ïπò`, 'info');

                removeRandomOpponentStone();

                if (checkWin(row, col)) {
                    const winner = currentPlayer === 1 ? player1Name : 
                                  currentPlayer === 2 ? player2Name : player3Name;
                    showModal(`${winner}Îãò ÏäπÎ¶¨!`, 'success', true);
                    clearInterval(timerId);
                    gameActive = false;
                    return;
                }

                addStonesFor30Moves();

                currentPlayer = (currentPlayer % (player3Name ? 3 : 2)) + 1;
                updateTurnInfo();
                updateSkillButton();
                updateEggSkillButton();
                startTimer();
                if (computerPlayers.includes(currentPlayer)) {
                    setTimeout(computerMove, 500);
                }
            }
        }

        function computerMove() {
            if (!gameActive || !computerPlayers.includes(currentPlayer)) return;

            if (isSkillMode && (currentPlayer === 1 ? player1MeteorSkill : 
                                currentPlayer === 2 ? player2MeteorSkill : player3MeteorSkill) > 0 && Math.random() < 0.5) {
                useMeteorStrike();
                return;
            }

            const result = minimax(board, 3, -Infinity, Infinity, true, currentPlayer);
            if (result.move) {
                const { row, col } = result.move;
                board[row][col] = currentPlayer;
                moveCount++;
                drawBoard();
                const playerName = currentPlayer === 1 ? player1Name : 
                                  currentPlayer === 2 ? player2Name : player3Name;
                log(`${playerName} (Ïª¥Ìì®ÌÑ∞)Ïù¥ (${row + 1}, ${col + 1})Ïóê Îèå Î∞∞Ïπò`, 'info');

                removeRandomOpponentStone();

                if (checkWin(row, col)) {
                    showModal(`${playerName} (Ïª¥Ìì®ÌÑ∞) ÏäπÎ¶¨!`, 'success', true);
                    gameActive = false;
                    return;
                }

                addStonesFor30Moves();

                currentPlayer = (currentPlayer % (player3Name ? 3 : 2)) + 1;
                updateTurnInfo();
                updateSkillButton();
                updateEggSkillButton();
                startTimer();
                if (computerPlayers.includes(currentPlayer)) {
                    setTimeout(computerMove, 500);
                }
            } else {
                showModal('ÎπàÏπ∏Ïù¥ ÏóÜÏñ¥ Ïª¥Ìì®ÌÑ∞Í∞Ä ÎèåÏùÑ ÎÜìÏùÑ Ïàò ÏóÜÏäµÎãàÎã§!', 'error');
            }
        }

        function checkWin(row, col) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            const player = board[row][col];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let dir = -1; dir <= 1; dir += 2) {
                    for (let i = 1; i <= 4; i++) {
                        const newRow = row + dr * i * dir;
                        const newCol = col + dc * i * dir;
                        if (
                            newRow >= 0 && newRow < boardSize &&
                            newCol >= 0 && newCol >= boardSize &&
                            board[newRow][newCol] === player
                        ) {
                            count++;
                        } else {
                            break;
                        }
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function updateTurnInfo() {
            const turnInfo = document.getElementById('turn-info');
            const playerName = currentPlayer === 1 ? player1Name : 
                              currentPlayer === 2 ? player2Name : player3Name;
            const stone = currentPlayer === 1 ? '‚óè ÌùëÎèå' : currentPlayer === 2 ? '‚óã Î∞±Îèå' : '‚óÜ Ï≤≠Îèå';
            const displayName = computerPlayers.includes(currentPlayer) ? `${playerName} (Ïª¥Ìì®ÌÑ∞)` : playerName;
            turnInfo.innerHTML = `ÌÑ¥: <span>${displayName}</span> (${stone})`;
        }

        function showModal(message, type = 'error', showRestart = false) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h2 style="color: ${type === 'success' ? '#27ae60' : '#e74c3c'}">${message}</h2>
                    <button onclick="closeModal()">ÌôïÏù∏</button>
                    ${showRestart ? '<button onclick="restartGame()">Îã§Ïãú ÏãúÏûë</button>' : ''}
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeModal() {
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        function restartGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            currentPlayer = 1;
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = isSkillMode ? 2 : 0;
            player2MeteorSkill = isSkillMode ? 2 : 0;
            player3MeteorSkill = isSkillMode && player3Name ? 2 : 0;
            player1EggSkill = isSkillMode ? 3 : 0;
            player2EggSkill = isSkillMode && !computerPlayers.includes(2) ? 3 : 0;
            player3EggSkill = isSkillMode && !computerPlayers.includes(3) && player3Name ? 3 : 0;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            logs = [];
            log('üéâ ÏÉà Í≤åÏûÑ ÏãúÏûë!', 'info');
            drawBoard();
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
            closeModal();
            if (computerPlayers.includes(currentPlayer)) {
                setTimeout(computerMove, 500);
            }
        }

        function log(message, type = 'info') {
            logs.push({ message, type });
            if (logs.length > 10) logs.shift();
            const logContainer = document.getElementById('game-log');
            logContainer.innerHTML = logs.map(log => `
                <div class="log-entry log-${log.type}">${log.message}</div>
            `).join('');
            requestAnimationFrame(() => {
                logContainer.scrollTop = logContainer.scrollHeight;
            });
        }

        canvas.addEventListener('click', handleCanvasClick);
    </script>
</body>
</html>
