<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2ì¸ìš© ì˜¤ëª© ê²Œì„ (19x19)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #333;
        }

        /* Start Screen */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .start-container {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            width: 90%;
        }

        .game-logo {
            font-size: 2em;
            color: #2c5282;
            margin-bottom: 10px;
        }

        .time-select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 2px solid #2c5282;
            border-radius: 6px;
            margin: 8px 0;
            background: #fff;
        }

        .start-btn {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        /* Game Container */
        .game-container {
            margin-top: 20px;
            text-align: center;
            max-width: 600px;
            width: 100%;
            padding: 10px;
            display: none;
        }

        .turn-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #2c5282;
        }

        .turn-info span {
            font-weight: 700;
            color: #e74c3c;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .button-container {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .restart-btn, .skill-btn, .egg-skill-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .restart-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .skill-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .egg-skill-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .restart-btn:hover, .skill-btn:hover, .egg-skill-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .skill-btn:disabled, .egg-skill-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Game Log */
        .game-log {
            background: #fff;
            border: 2px solid #2c5282;
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            border-left: 2px solid;
        }

        .log-success { border-left-color: #27ae60; color: #27ae60; }
        .log-error { border-left-color: #e74c3c; color: #e74c3c; }
        .log-info { border-left-color: #2c5282; color: #2c5282; }
        .log-warning { border-left-color: #f39c12; color: #f39c12; }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            width: 90%;
            text-align: center;
        }

        .modal-content h2 {
            color: #2c5282;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .modal-content button {
            padding: 8px 12px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            margin: 5px;
        }

        .modal-content button:hover {
            background: linear-gradient(45deg, #3b82f6, #2c5282);
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }
            .start-container {
                padding: 15px;
                max-width: 280px;
            }
            .game-logo {
                font-size: 1.6em;
            }
            .modal-content {
                max-width: 250px;
            }
            .game-log {
                max-height: 100px;
            }
            .button-container {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="start-screen">
        <div class="start-container">
            <div class="game-logo">âš«âšª ì˜¤ëª© ê²Œì„ (19x19)</div>
            <select class="time-select" id="time-limit" aria-label="ì‹œê°„ ì œí•œ ì„ íƒ">
                <option value="10000">10ì´ˆ</option>
                <option value="30000">30ì´ˆ</option>
                <option value="60000">1ë¶„</option>
            </select>
            <button class="start-btn" onclick="startGame()" aria-label="ê²Œì„ ì‹œì‘">ê²Œì„ ì‹œì‘</button>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="game-container">
        <div class="turn-info" id="turn-info">í„´: <span>í‘</span> (â— í‘ëŒ)</div>
        <canvas id="game-board" width="570" height="570"></canvas>
        <div class="button-container">
            <button class="restart-btn" onclick="restartGame()" aria-label="ë‹¤ì‹œ ì‹œì‘">ë‹¤ì‹œ ì‹œì‘</button>
            <button class="skill-btn" id="skill-btn" onclick="useMeteorStrike()" aria-label="ìš´ì„ ë‚™í•˜">ìš´ì„ ë‚™í•˜ (2)</button>
            <button class="egg-skill-btn" id="egg-skill-btn" onclick="toggleEggSkillMode()" aria-label="ì•Œê¹Œê¸°">ì•Œê¹Œê¸° (3)</button>
        </div>
        <div class="game-log" id="game-log">
            <div class="log-entry log-info">ğŸ‰ ì˜¤ëª© ê²Œì„ ì‹œì‘!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const boardSize = 19;
        const cellSize = 30;
        let board = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); // 0: ë¹ˆì¹¸, 1: í‘ëŒ, 2: ë°±ëŒ
        let currentPlayer = 1; // 1: í‘ëŒ, 2: ë°±ëŒ
        let player1Name = 'í‘';
        let player2Name = 'ë°±';
        let gameActive = false;
        let timeLimit = 10000; // ê¸°ë³¸ 10ì´ˆ
        let timerId = null;
        let timeLeft = 0;
        let logs = [];
        let moveCount = 0; // ëŒ ë°°ì¹˜ íšŸìˆ˜ ì¶”ì 
        let player1MeteorSkill = 2; // ìš´ì„ ìŠ¤í‚¬ íšŸìˆ˜
        let player2MeteorSkill = 2;
        let player1EggSkill = 3; // ì•Œê¹Œê¸° ìŠ¤í‚¬ íšŸìˆ˜
        let player2EggSkill = 3;
        let isEggSkillMode = false;
        let selectedRow = -1;
        let selectedCol = -1;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragEndX = 0;
        let dragEndY = 0;
        let isDragging = false;
        let animationFrameId = null;

        document.addEventListener('DOMContentLoaded', () => {
            drawBoard();
            updateSkillButton();
            updateEggSkillButton();
        });

        function startGame() {
            timeLimit = parseInt(document.getElementById('time-limit').value);
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = 2;
            player2MeteorSkill = 2;
            player1EggSkill = 3;
            player2EggSkill = 3;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            startTimer();
            updateTurnInfo();
            drawBoard();
            updateSkillButton();
            updateEggSkillButton();
            log('ğŸ‰ ê²Œì„ ì‹œì‘!', 'info');
        }

        function drawBoard() {
            // ë¬´ì§€ê°œìƒ‰ ê·¸ë¼ë””ì–¸íŠ¸ ë°°ê²½
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            const hue = (Date.now() / 1000) % 360;
            gradient.addColorStop(0, `hsl(${hue}, 80%, 50%)`);
            gradient.addColorStop(0.2, `hsl(${hue + 60}, 80%, 50%)`);
            gradient.addColorStop(0.4, `hsl(${hue + 120}, 80%, 50%)`);
            gradient.addColorStop(0.6, `hsl(${hue + 180}, 80%, 50%)`);
            gradient.addColorStop(0.8, `hsl(${hue + 240}, 80%, 50%)`);
            gradient.addColorStop(1, `hsl(${hue + 300}, 80%, 50%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ì˜¤ëª© ë³´ë“œ ë°°ê²½ìƒ‰ ë³€í™” (ì‹œê°„ì— ë”°ë¼ ì²­ìƒ‰ â†’ ë¹¨ê°•)
            const fullness = timeLeft / (timeLimit / 1000); // 1 (ë§Œë•…) ~ 0 (ì´ˆê³¼)
            const baseHue = 240; // ë§Œë•…: ì²­ìƒ‰ (hue 240)
            const targetHue = 0; // ì´ˆê³¼: ë¹¨ê°• (hue 0)
            const boardHue = baseHue - (baseHue - targetHue) * (1 - fullness);
            ctx.fillStyle = `hsl(${boardHue}, 50%, 70%)`;
            ctx.fillRect(cellSize / 2, cellSize / 2, canvas.width - cellSize, canvas.height - cellSize);

            // ê²©ì ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize / 2 + i * cellSize, cellSize / 2);
                ctx.lineTo(cellSize / 2 + i * cellSize, canvas.height - cellSize / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.lineTo(canvas.width - cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.stroke();
            }

            // ì‹œê°„ í‘œì‹œ
            ctx.font = '24px Roboto';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            textGradient.addColorStop(0, `hsl(${hue + 30}, 80%, 50%)`);
            textGradient.addColorStop(0.5, `hsl(${hue + 90}, 80%, 50%)`);
            textGradient.addColorStop(1, `hsl(${hue + 150}, 80%, 50%)`);
            ctx.fillStyle = textGradient;
            ctx.fillText(`ë‚¨ì€ ì‹œê°„: ${timeLeft}ì´ˆ`, canvas.width / 2, 20);

            // ëŒ ê·¸ë¦¬ê¸°
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 1) {
                        ctx.fillStyle = '#000';
                        drawStone(row, col, 1.0);
                    } else if (board[row][col] === 2) {
                        ctx.fillStyle = '#fff';
                        drawStone(row, col, 1.0);
                    }
                }
            }
        }

        function drawStone(row, col, opacity = 1.0) {
            ctx.globalAlpha = opacity;
            ctx.beginPath();
            ctx.arc(cellSize / 2 + col * cellSize, cellSize / 2 + row * cellSize, cellSize / 2 - 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            if (isEggSkillMode) return; // ì•Œê¹Œê¸° ëª¨ë“œì—ì„œëŠ” íƒ€ì´ë¨¸ ì¤‘ì§€
            timeLeft = timeLimit / 1000;
            drawBoard();
            timerId = setInterval(() => {
                timeLeft--;
                drawBoard();
                if (timeLeft <= 0) {
                    clearInterval(timerId);
                    const loser = currentPlayer === 1 ? player1Name : player2Name;
                    const winner = currentPlayer === 1 ? player2Name : player1Name;
                    log(`${loser}ë‹˜ ì‹œê°„ ì´ˆê³¼ íŒ¨ë°°!`, 'error');
                    showModal(`${winner}ë‹˜ ì‹œê°„íŒ¨ ìŠ¹ë¦¬!`, 'success', true);
                    gameActive = false;
                }
            }, 1000);
        }

        function removeRandomOpponentStone() {
            if (moveCount < 2) return; // ì²« í„´ì—ì„œëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ
            const opponent = currentPlayer === 1 ? 2 : 1;
            const opponentStones = [];

            // ìƒëŒ€ë°© ëŒ ìœ„ì¹˜ ìˆ˜ì§‘
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === opponent) {
                        opponentStones.push({ row, col });
                    }
                }
            }

            if (opponentStones.length === 0) {
                log('âš¡ ì œê±°í•  ìƒëŒ€ë°© ëŒì´ ì—†ìŠµë‹ˆë‹¤!', 'warning');
                return;
            }

            // 10% í™•ë¥ ë¡œ ì œê±°
            if (Math.random() < 0.1) {
                const randomIndex = Math.floor(Math.random() * opponentStones.length);
                const { row, col } = opponentStones[randomIndex];
                board[row][col] = 0;
                log(`âš¡ ${currentPlayer === 1 ? player2Name : player1Name}ë‹˜ì˜ ëŒ (${row + 1}, ${col + 1}) ì œê±°!`, 'warning');
                drawBoard();
            }
        }

        function useMeteorStrike() {
            if (!gameActive) return;
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : player2MeteorSkill;
            if (skillCount <= 0) {
                showModal(`${currentPlayer === 1 ? player1Name : player2Name}ë‹˜ì€ ìš´ì„ ìŠ¤í‚¬ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤!`, 'error');
                return;
            }

            // ë¹ˆì¹¸ ìˆ˜ì§‘
            const emptyCells = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 0) {
                        emptyCells.push({ row, col });
                    }
                }
            }

            if (emptyCells.length === 0) {
                showModal('ë¹ˆì¹¸ì´ ì—†ì–´ ìŠ¤í‚¬ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!', 'error');
                return;
            }

            // ìµœëŒ€ 10ê°œ ëŒ ë°°ì¹˜
            const stonesToPlace = Math.min(10, emptyCells.length);
            for (let i = 0; i < stonesToPlace; i++) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                const { row, col } = emptyCells[randomIndex];
                board[row][col] = currentPlayer;
                emptyCells.splice(randomIndex, 1);
                log(`â˜„ ìš´ì„ ë‚™í•˜: (${row + 1}, ${col + 1})ì— ëŒ ë°°ì¹˜`, 'info');
            }

            drawBoard();
            log(`â˜„ ${currentPlayer === 1 ? player1Name : player2Name}ë‹˜ì´ ìš´ì„ ë‚™í•˜ ìŠ¤í‚¬ ì‚¬ìš©!`, 'warning');

            if (currentPlayer === 1) player1MeteorSkill--;
            else player2MeteorSkill--;
            updateSkillButton();

            // ìŠ¹ë¦¬ ì²´í¬
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === currentPlayer && checkWin(row, col)) {
                        const winner = currentPlayer === 1 ? player1Name : player2Name;
                        showModal(`${winner}ë‹˜ ìŠ¹ë¦¬!`, 'success', true);
                        clearInterval(timerId);
                        gameActive = false;
                        return;
                    }
                }
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
        }

        function toggleEggSkillMode() {
            if (!gameActive) return;
            const skillCount = currentPlayer === 1 ? player1EggSkill : player2EggSkill;
            if (skillCount <= 0) {
                showModal('ì•Œê¹Œê¸° ìŠ¤í‚¬ ì‚¬ìš© íšŸìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤!', 'error');
                return;
            }

            isEggSkillMode = !isEggSkillMode;
            selectedRow = -1;
            selectedCol = -1;
            if (isEggSkillMode) {
                if (timerId) clearInterval(timerId); // íƒ€ì´ë¨¸ ì¤‘ì§€
                log(`ğŸª¶ ${currentPlayer === 1 ? player1Name : player2Name}ë‹˜ ì•Œê¹Œê¸° ëª¨ë“œ í™œì„±í™”! ìì‹ ì˜ ëŒ ì„ íƒ`, 'warning');
            } else {
                updateEggSkillButton();
                startTimer();
            }
            updateEggSkillButton();
        }

        function updateEggSkillButton() {
            const skillCount = currentPlayer === 1 ? player1EggSkill : player2EggSkill;
            const eggSkillBtn = document.getElementById('egg-skill-btn');
            eggSkillBtn.disabled = skillCount <= 0 && !isEggSkillMode;
            eggSkillBtn.textContent = isEggSkillMode ? 'ì•Œê¹Œê¸° ì·¨ì†Œ' : `ì•Œê¹Œê¸° (${skillCount})`;
        }

        function updateSkillButton() {
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : player2MeteorSkill;
            const skillBtn = document.getElementById('skill-btn');
            skillBtn.disabled = skillCount <= 0;
            skillBtn.textContent = `ìš´ì„ ë‚™í•˜ (${skillCount})`;
        }

        function handleCanvasMouseDown(event) {
            if (!gameActive || !isEggSkillMode) return;
            const rect = canvas.getBoundingClientRect();
            dragStartX = event.clientX - rect.left;
            dragStartY = event.clientY - rect.top;
            const col = Math.floor(dragStartX / cellSize);
            const row = Math.floor(dragStartY / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;
            if (board[row][col] === currentPlayer) {
                selectedRow = row;
                selectedCol = col;
                isDragging = true;
                log(`ğŸª¶ ìì‹ ì˜ ëŒ (${row + 1}, ${col + 1}) ì„ íƒ. ë“œë˜ê·¸í•˜ì—¬ ë°©í–¥ ì„ íƒ`, 'info');
            }
        }

        function handleCanvasMouseMove(event) {
            if (!isDragging || !isEggSkillMode) return;
            const rect = canvas.getBoundingClientRect();
            dragEndX = event.clientX - rect.left;
            dragEndY = event.clientY - rect.top;
            drawBoard();
            // ê³ ë¬´ì¤„ íš¨ê³¼
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cellSize / 2 + selectedCol * cellSize, cellSize / 2 + selectedRow * cellSize);
            ctx.lineTo(dragEndX, dragEndY);
            ctx.stroke();
        }

        function handleCanvasMouseUp(event) {
            if (!isDragging || !isEggSkillMode) return;
            isDragging = false;
            const rect = canvas.getBoundingClientRect();
            dragEndX = event.clientX - rect.left;
            dragEndY = event.clientY - rect.top;

            // ë°©í–¥ ê³„ì‚°
            const dx = dragEndX - (cellSize / 2 + selectedCol * cellSize);
            const dy = dragEndY - (cellSize / 2 + selectedRow * cellSize);
            const angle = Math.atan2(dy, dx);
            const threshold = cellSize * 0.5; // ëŒ€ê°ì„  íŒë‹¨ì„ ìœ„í•œ ì„ê³„ê°’
            let dr, dc;

            // ë°©í–¥ ê²°ì •: ê°€ë¡œ, ì„¸ë¡œ, ìš°í•˜, ì¢Œí•˜
            if (Math.abs(dx) > Math.abs(dy) && (Math.abs(angle) < Math.PI / 4 || Math.abs(angle) > 3 * Math.PI / 4)) {
                // ê°€ë¡œ
                dr = 0;
                dc = dx > 0 ? 1 : -1;
            } else if (Math.abs(dy) > Math.abs(dx) && (Math.abs(angle) > Math.PI / 4 && Math.abs(angle) < 3 * Math.PI / 4)) {
                // ì„¸ë¡œ
                dr = dy > 0 ? 1 : -1;
                dc = 0;
            } else if (dx > 0 && dy > 0 && Math.abs(dx - dy) < threshold) {
                // ìš°í•˜ ëŒ€ê°ì„ 
                dr = 1;
                dc = 1;
            } else if (dx < 0 && dy > 0 && Math.abs(dx + dy) < threshold) {
                // ì¢Œí•˜ ëŒ€ê°ì„ 
                dr = 1;
                dc = -1;
            } else {
                // ìœ íš¨í•˜ì§€ ì•Šì€ ë“œë˜ê·¸, ì·¨ì†Œ
                isEggSkillMode = false;
                updateEggSkillButton();
                startTimer();
                log(`ğŸª¶ ì•Œê¹Œê¸° ë°©í–¥ ì„ íƒ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.`, 'error');
                return;
            }

            // ì• ë‹ˆë©”ì´ì…˜: ëŒ ì´ë™ ë° ìƒëŒ€ ëŒ ì œê±°
            const stonesToRemove = [];
            let row = selectedRow;
            let col = selectedCol;
            while (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {
                if (board[row][col] === (currentPlayer === 1 ? 2 : 1)) {
                    stonesToRemove.push({ row, col });
                }
                row += dr;
                col += dc;
            }

            let animationProgress = 0;
            const animationDuration = 500; // 500ms
            function animate() {
                drawBoard();
                const t = animationProgress / animationDuration;
                const opacity = 1 - t; // í˜ì´ë“œì•„ì›ƒ
                const moveDistance = t * 5 * cellSize; // 5ì¹¸ ì´ë™
                const moveX = cellSize / 2 + selectedCol * cellSize + moveDistance * dc;
                const moveY = cellSize / 2 + selectedRow * cellSize + moveDistance * dr;
                ctx.fillStyle = currentPlayer === 1 ? '#000' : '#fff';
                drawStone(selectedRow, selectedCol, opacity);
                ctx.beginPath();
                ctx.arc(moveX, moveY, cellSize / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                stonesToRemove.forEach(({ row, col }) => {
                    ctx.fillStyle = currentPlayer === 1 ? '#fff' : '#000';
                    drawStone(row, col, opacity);
                });

                animationProgress += 16; // ì•½ 60fps
                if (animationProgress < animationDuration) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ
                    cancelAnimationFrame(animationFrameId);
                    board[selectedRow][selectedCol] = 0; // ì„ íƒí•œ ëŒ ì œê±°
                    stonesToRemove.forEach(({ row, col }) => {
                        board[row][col] = 0;
                        log(`ğŸª¶ ìƒëŒ€ ëŒ (${row + 1}, ${col + 1}) ì œê±°!`, 'warning');
                    });
                    drawBoard();
                    log(`ğŸª¶ ${currentPlayer === 1 ? player1Name : player2Name}ë‹˜ì´ ì•Œê¹Œê¸° ìŠ¤í‚¬ ì‚¬ìš©!`, 'warning');
                    if (currentPlayer === 1) player1EggSkill--;
                    else player2EggSkill--;
                    isEggSkillMode = false;
                    updateEggSkillButton();
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    updateTurnInfo();
                    updateSkillButton();
                    startTimer();
                }
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        function handleCanvasClick(event) {
            if (!gameActive || isEggSkillMode) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;
            if (board[row][col] !== 0) return;

            board[row][col] = currentPlayer;
            moveCount++;
            drawBoard();
            log(`${currentPlayer === 1 ? player1Name : player2Name}ë‹˜ì´ (${row + 1}, ${col + 1})ì— ëŒ ë°°ì¹˜`, 'info');

            removeRandomOpponentStone();

            if (checkWin(row, col)) {
                const winner = currentPlayer === 1 ? player1Name : player2Name;
                showModal(`${winner}ë‹˜ ìŠ¹ë¦¬!`, 'success', true);
                clearInterval(timerId);
                gameActive = false;
                return;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
        }

        function checkWin(row, col) {
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1] // ê°€ë¡œ, ì„¸ë¡œ, ëŒ€ê°ì„ (ìš°í•˜, ì¢Œí•˜)
            ];
            const player = board[row][col];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let dir = -1; dir <= 1; dir += 2) {
                    for (let i = 1; i <= 4; i++) {
                        const newRow = row + dr * i * dir;
                        const newCol = col + dc * i * dir;
                        if (
                            newRow >= 0 && newRow < boardSize &&
                            newCol >= 0 && newCol < boardSize &&
                            board[newRow][newCol] === player
                        ) {
                            count++;
                        } else {
                            break;
                        }
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function updateTurnInfo() {
            const turnInfo = document.getElementById('turn-info');
            const playerName = currentPlayer === 1 ? player1Name : player2Name;
            const stone = currentPlayer === 1 ? 'â— í‘ëŒ' : 'â—‹ ë°±ëŒ';
            turnInfo.innerHTML = `í„´: <span>${playerName}</span> (${stone})`;
        }

        function showModal(message, type = 'error', showRestart = false) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h2 style="color: ${type === 'success' ? '#27ae60' : '#e74c3c'}">${message}</h2>
                    <button onclick="closeModal()">í™•ì¸</button>
                    ${showRestart ? '<button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>' : ''}
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeModal() {
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        function restartGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            currentPlayer = 1;
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = 2;
            player2MeteorSkill = 2;
            player1EggSkill = 3;
            player2EggSkill = 3;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            isDragging = false;
            logs = [];
            log('ğŸ‰ ìƒˆ ê²Œì„ ì‹œì‘!', 'info');
            drawBoard();
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
            closeModal();
        }

        function log(message, type = 'info') {
            logs.push({ message, type });
            if (logs.length > 10) logs.shift();
            const logContainer = document.getElementById('game-log');
            logContainer.innerHTML = logs.map(log => `
                <div class="log-entry log-${log.type}">${log.message}</div>
            `).join('');
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
    </script>
</body>
</html>
