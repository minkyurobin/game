<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2Ïù∏Ïö© Ïò§Î™© Í≤åÏûÑ (19x19)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #333;
        }

        /* Start Screen */
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .start-container {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            max-width: 350px;
            width: 90%;
        }

        .game-logo {
            font-size: 2em;
            color: #2c5282;
            margin-bottom: 10px;
        }

        .time-select {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            border: 2px solid #2c5282;
            border-radius: 6px;
            margin: 8px 0;
            background: #fff;
        }

        .start-btn {
            width: 100%;
            padding: 10px;
            font-size: 16px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        /* Game Container */
        .game-container {
            margin-top: 20px;
            text-align: center;
            max-width: 600px;
            width: 100%;
            padding: 10px;
            display: none;
        }

        .turn-info {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #2c5282;
        }

        .turn-info span {
            font-weight: 700;
            color: #e74c3c;
        }

        canvas {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .button-container {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .restart-btn, .skill-btn, .egg-skill-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .restart-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
        }

        .skill-btn {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        .egg-skill-btn {
            background: linear-gradient(45deg, #27ae60, #2ecc71);
        }

        .restart-btn:hover, .skill-btn:hover, .egg-skill-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .skill-btn:disabled, .egg-skill-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Game Log */
        .game-log {
            background: #fff;
            border: 2px solid #2c5282;
            border-radius: 8px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            border-left: 2px solid;
        }

        .log-success { border-left-color: #27ae60; color: #27ae60; }
        .log-error { border-left-color: #e74c3c; color: #e74c3c; }
        .log-info { border-left-color: #2c5282; color: #2c5282; }
        .log-warning { border-left-color: #f39c12; color: #f39c12; }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .modal-content {
            background: #fff;
            border: 3px solid #2c5282;
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            width: 90%;
            text-align: center;
        }

        .modal-content h2 {
            color: #2c5282;
            font-size: 1.3em;
            margin-bottom: 15px;
        }

        .modal-content button {
            padding: 8px 12px;
            background: linear-gradient(45deg, #2c5282, #3b82f6);
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            margin: 5px;
        }

        .modal-content button:hover {
            background: linear-gradient(45deg, #3b82f6, #2c5282);
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            canvas {
                width: 100%;
                height: auto;
            }
            .start-container {
                padding: 15px;
                max-width: 280px;
            }
            .game-logo {
                font-size: 1.6em;
            }
            .modal-content {
                max-width: 250px;
            }
            .game-log {
                max-height: 100px;
            }
            .button-container {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div class="start-screen" id="start-screen">
        <div class="start-container">
            <div class="game-logo">‚ö´‚ö™ Ïò§Î™© Í≤åÏûÑ (19x19)</div>
            <select class="time-select" id="time-limit" aria-label="ÏãúÍ∞Ñ Ï†úÌïú ÏÑ†ÌÉù">
                <option value="10000">10Ï¥à</option>
                <option value="30000">30Ï¥à</option>
                <option value="60000">1Î∂Ñ</option>
            </select>
            <button class="start-btn" onclick="startGame()" aria-label="Í≤åÏûÑ ÏãúÏûë">Í≤åÏûÑ ÏãúÏûë</button>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container" id="game-container">
        <div class="turn-info" id="turn-info">ÌÑ¥: <span>Ìùë</span> (‚óè ÌùëÎèå)</div>
        <canvas id="game-board" width="570" height="570"></canvas>
        <div class="button-container">
            <button class="restart-btn" onclick="restartGame()" aria-label="Îã§Ïãú ÏãúÏûë">Îã§Ïãú ÏãúÏûë</button>
            <button class="skill-btn" id="skill-btn" onclick="useMeteorStrike()" aria-label="Ïö¥ÏÑù ÎÇôÌïò">Ïö¥ÏÑù ÎÇôÌïò (2)</button>
            <button class="egg-skill-btn" id="egg-skill-btn" onclick="toggleEggSkillMode()" aria-label="ÏïåÍπåÍ∏∞">ÏïåÍπåÍ∏∞ (3)</button>
        </div>
        <div class="game-log" id="game-log">
            <div class="log-entry log-info">üéâ Ïò§Î™© Í≤åÏûÑ ÏãúÏûë!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        const boardSize = 19;
        const cellSize = 30;
        let board = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); // 0: ÎπàÏπ∏, 1: ÌùëÎèå, 2: Î∞±Îèå
        let currentPlayer = 1; // 1: ÌùëÎèå, 2: Î∞±Îèå
        let player1Name = 'Ìùë';
        let player2Name = 'Î∞±';
        let gameActive = false;
        let timeLimit = 10000; // Í∏∞Î≥∏ 10Ï¥à
        let timerId = null;
        let timeLeft = 0;
        let logs = [];
        let moveCount = 0; // Îèå Î∞∞Ïπò ÌöüÏàò Ï∂îÏ†Å
        let player1MeteorSkill = 2; // Ïö¥ÏÑù Ïä§ÌÇ¨ ÌöüÏàò
        let player2MeteorSkill = 2;
        let player1EggSkill = 3; // ÏïåÍπåÍ∏∞ Ïä§ÌÇ¨ ÌöüÏàò
        let player2EggSkill = 3;
        let isEggSkillMode = false;
        let selectedRow = -1;
        let selectedCol = -1;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragEndX = 0;
        let dragEndY = 0;
        let isDragging = false;
        let animationFrameId = null;

        document.addEventListener('DOMContentLoaded', () => {
            drawBoard();
            updateSkillButton();
            updateEggSkillButton();
        });

        function startGame() {
            timeLimit = parseInt(document.getElementById('time-limit').value);
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = 2;
            player2MeteorSkill = 2;
            player1EggSkill = 3;
            player2EggSkill = 3;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            startTimer();
            updateTurnInfo();
            drawBoard();
            updateSkillButton();
            updateEggSkillButton();
            log('üéâ Í≤åÏûÑ ÏãúÏûë!', 'info');
        }

        function drawBoard() {
            // Î¨¥ÏßÄÍ∞úÏÉâ Í∑∏ÎùºÎîîÏñ∏Ìä∏ Î∞∞Í≤Ω
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            const hue = (Date.now() / 1000) % 360;
            gradient.addColorStop(0, `hsl(${hue}, 80%, 50%)`);
            gradient.addColorStop(0.2, `hsl(${hue + 60}, 80%, 50%)`);
            gradient.addColorStop(0.4, `hsl(${hue + 120}, 80%, 50%)`);
            gradient.addColorStop(0.6, `hsl(${hue + 180}, 80%, 50%)`);
            gradient.addColorStop(0.8, `hsl(${hue + 240}, 80%, 50%)`);
            gradient.addColorStop(1, `hsl(${hue + 300}, 80%, 50%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Ïò§Î™© Î≥¥Îìú Î∞∞Í≤ΩÏÉâ Î≥ÄÌôî (ÏãúÍ∞ÑÏóê Îî∞Îùº Ï≤≠ÏÉâ ‚Üí Îπ®Í∞ï)
            const fullness = timeLeft / (timeLimit / 1000); // 1 (ÎßåÎïÖ) ~ 0 (Ï¥àÍ≥º)
            const baseHue = 240; // ÎßåÎïÖ: Ï≤≠ÏÉâ (hue 240)
            const targetHue = 0; // Ï¥àÍ≥º: Îπ®Í∞ï (hue 0)
            const boardHue = baseHue - (baseHue - targetHue) * (1 - fullness);
            ctx.fillStyle = `hsl(${boardHue}, 50%, 70%)`;
            ctx.fillRect(cellSize / 2, cellSize / 2, canvas.width - cellSize, canvas.height - cellSize);

            // Í≤©Ïûê Í∑∏Î¶¨Í∏∞
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(cellSize / 2 + i * cellSize, cellSize / 2);
                ctx.lineTo(cellSize / 2 + i * cellSize, canvas.height - cellSize / 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.lineTo(canvas.width - cellSize / 2, cellSize / 2 + i * cellSize);
                ctx.stroke();
            }

            // ÏãúÍ∞Ñ ÌëúÏãú
            ctx.font = '24px Roboto';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            textGradient.addColorStop(0, `hsl(${hue + 30}, 80%, 50%)`);
            textGradient.addColorStop(0.5, `hsl(${hue + 90}, 80%, 50%)`);
            textGradient.addColorStop(1, `hsl(${hue + 150}, 80%, 50%)`);
            ctx.fillStyle = textGradient;
            ctx.fillText(`ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${timeLeft}Ï¥à`, canvas.width / 2, 20);

            // Îèå Í∑∏Î¶¨Í∏∞
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 1) {
                        ctx.fillStyle = '#000';
                        drawStone(row, col, 1.0);
                    } else if (board[row][col] === 2) {
                        ctx.fillStyle = '#fff';
                        drawStone(row, col, 1.0);
                    }
                }
            }
        }

        function drawStone(row, col, opacity = 1.0) {
            ctx.globalAlpha = opacity;
            ctx.beginPath();
            ctx.arc(cellSize / 2 + col * cellSize, cellSize / 2 + row * cellSize, cellSize / 2 - 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function startTimer() {
            if (timerId) clearInterval(timerId);
            if (isEggSkillMode) return; // ÏïåÍπåÍ∏∞ Î™®ÎìúÏóêÏÑúÎäî ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
            timeLeft = timeLimit / 1000;
            drawBoard();
            timerId = setInterval(() => {
                timeLeft--;
                drawBoard();
                if (timeLeft <= 0) {
                    clearInterval(timerId);
                    const loser = currentPlayer === 1 ? player1Name : player2Name;
                    const winner = currentPlayer === 1 ? player2Name : player1Name;
                    log(`${loser}Îãò ÏãúÍ∞Ñ Ï¥àÍ≥º Ìå®Î∞∞!`, 'error');
                    showModal(`${winner}Îãò ÏãúÍ∞ÑÌå® ÏäπÎ¶¨!`, 'success', true);
                    gameActive = false;
                }
            }, 1000);
        }

        function removeRandomOpponentStone() {
            if (moveCount < 2) return; // Ï≤´ ÌÑ¥ÏóêÏÑúÎäî Ï†úÍ±∞ÌïòÏßÄ ÏïäÏùå
            const opponent = currentPlayer === 1 ? 2 : 1;
            const opponentStones = [];

            // ÏÉÅÎåÄÎ∞© Îèå ÏúÑÏπò ÏàòÏßë
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === opponent) {
                        opponentStones.push({ row, col });
                    }
                }
            }

            if (opponentStones.length === 0) {
                log('‚ö° Ï†úÍ±∞Ìï† ÏÉÅÎåÄÎ∞© ÎèåÏù¥ ÏóÜÏäµÎãàÎã§!', 'warning');
                return;
            }

            // 10% ÌôïÎ•†Î°ú Ï†úÍ±∞
            if (Math.random() < 0.1) {
                const randomIndex = Math.floor(Math.random() * opponentStones.length);
                const { row, col } = opponentStones[randomIndex];
                board[row][col] = 0;
                log(`‚ö° ${currentPlayer === 1 ? player2Name : player1Name}ÎãòÏùò Îèå (${row + 1}, ${col + 1}) Ï†úÍ±∞!`, 'warning');
                drawBoard();
            }
        }

        function useMeteorStrike() {
            if (!gameActive) return;
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : player2MeteorSkill;
            if (skillCount <= 0) {
                showModal(`${currentPlayer === 1 ? player1Name : player2Name}ÎãòÏùÄ Ïö¥ÏÑù Ïä§ÌÇ¨ÏùÑ Î™®Îëê ÏÇ¨Ïö©ÌñàÏäµÎãàÎã§!`, 'error');
                return;
            }

            // ÎπàÏπ∏ ÏàòÏßë
            const emptyCells = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === 0) {
                        emptyCells.push({ row, col });
                    }
                }
            }

            if (emptyCells.length === 0) {
                showModal('ÎπàÏπ∏Ïù¥ ÏóÜÏñ¥ Ïä§ÌÇ¨ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§!', 'error');
                return;
            }

            // ÏµúÎåÄ 10Í∞ú Îèå Î∞∞Ïπò
            const stonesToPlace = Math.min(10, emptyCells.length);
            for (let i = 0; i < stonesToPlace; i++) {
                const randomIndex = Math.floor(Math.random() * emptyCells.length);
                const { row, col } = emptyCells[randomIndex];
                board[row][col] = currentPlayer;
                emptyCells.splice(randomIndex, 1);
                log(`‚òÑ Ïö¥ÏÑù ÎÇôÌïò: (${row + 1}, ${col + 1})Ïóê Îèå Î∞∞Ïπò`, 'info');
            }

            drawBoard();
            log(`‚òÑ ${currentPlayer === 1 ? player1Name : player2Name}ÎãòÏù¥ Ïö¥ÏÑù ÎÇôÌïò Ïä§ÌÇ¨ ÏÇ¨Ïö©!`, 'warning');

            if (currentPlayer === 1) player1MeteorSkill--;
            else player2MeteorSkill--;
            updateSkillButton();

            // ÏäπÎ¶¨ Ï≤¥ÌÅ¨
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (board[row][col] === currentPlayer && checkWin(row, col)) {
                        const winner = currentPlayer === 1 ? player1Name : player2Name;
                        showModal(`${winner}Îãò ÏäπÎ¶¨!`, 'success', true);
                        clearInterval(timerId);
                        gameActive = false;
                        return;
                    }
                }
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
        }

        function toggleEggSkillMode() {
            if (!gameActive) return;
            const skillCount = currentPlayer === 1 ? player1EggSkill : player2EggSkill;
            if (skillCount <= 0) {
                showModal('ÏïåÍπåÍ∏∞ Ïä§ÌÇ¨ ÏÇ¨Ïö© ÌöüÏàòÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'error');
                return;
            }

            isEggSkillMode = !isEggSkillMode;
            selectedRow = -1;
            selectedCol = -1;
            if (isEggSkillMode) {
                if (timerId) clearInterval(timerId); // ÌÉÄÏù¥Î®∏ Ï§ëÏßÄ
                log(`ü™∂ ${currentPlayer === 1 ? player1Name : player2Name}Îãò ÏïåÍπåÍ∏∞ Î™®Îìú ÌôúÏÑ±Ìôî! ÏûêÏã†Ïùò Îèå ÏÑ†ÌÉù`, 'warning');
            } else {
                updateEggSkillButton();
                startTimer();
            }
            updateEggSkillButton();
        }

        function updateEggSkillButton() {
            const skillCount = currentPlayer === 1 ? player1EggSkill : player2EggSkill;
            const eggSkillBtn = document.getElementById('egg-skill-btn');
            eggSkillBtn.disabled = skillCount <= 0 && !isEggSkillMode;
            eggSkillBtn.textContent = isEggSkillMode ? 'ÏïåÍπåÍ∏∞ Ï∑®ÏÜå' : `ÏïåÍπåÍ∏∞ (${skillCount})`;
        }

        function updateSkillButton() {
            const skillCount = currentPlayer === 1 ? player1MeteorSkill : player2MeteorSkill;
            const skillBtn = document.getElementById('skill-btn');
            skillBtn.disabled = skillCount <= 0;
            skillBtn.textContent = `Ïö¥ÏÑù ÎÇôÌïò (${skillCount})`;
        }

        function handleCanvasMouseDown(event) {
            if (!gameActive || !isEggSkillMode) return;
            const rect = canvas.getBoundingClientRect();
            dragStartX = event.clientX - rect.left;
            dragStartY = event.clientY - rect.top;
            const col = Math.floor(dragStartX / cellSize);
            const row = Math.floor(dragStartY / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;
            if (board[row][col] === currentPlayer) {
                selectedRow = row;
                selectedCol = col;
                isDragging = true;
                log(`ü™∂ ÏûêÏã†Ïùò Îèå (${row + 1}, ${col + 1}) ÏÑ†ÌÉù. ÎìúÎûòÍ∑∏ÌïòÏó¨ Î∞©Ìñ• ÏÑ†ÌÉù`, 'info');
            }
        }

        function handleCanvasMouseMove(event) {
            if (!isDragging || !isEggSkillMode) return;
            const rect = canvas.getBoundingClientRect();
            dragEndX = event.clientX - rect.left;
            dragEndY = event.clientY - rect.top;
            drawBoard();
            // Í≥†Î¨¥Ï§Ñ Ìö®Í≥º
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cellSize / 2 + selectedCol * cellSize, cellSize / 2 + selectedRow * cellSize);
            ctx.lineTo(dragEndX, dragEndY);
            ctx.stroke();
        }

        function handleCanvasMouseUp(event) {
            if (!isDragging || !isEggSkillMode) return;
            isDragging = false;
            const rect = canvas.getBoundingClientRect();
            dragEndX = event.clientX - rect.left;
            dragEndY = event.clientY - rect.top;

            // Î∞©Ìñ• Í≥ÑÏÇ∞
            const dx = dragEndX - (cellSize / 2 + selectedCol * cellSize);
            const dy = dragEndY - (cellSize / 2 + selectedRow * cellSize);
            const angle = Math.atan2(dy, dx);
            const threshold = cellSize * 0.5; // ÎåÄÍ∞ÅÏÑ† ÌåêÎã®ÏùÑ ÏúÑÌïú ÏûÑÍ≥ÑÍ∞í
            let dr, dc;

            // Î∞©Ìñ• Í≤∞Ï†ï: Í∞ÄÎ°ú, ÏÑ∏Î°ú, Ïö∞Ìïò, Ï¢åÌïò
            if (Math.abs(dx) > Math.abs(dy) && (Math.abs(angle) < Math.PI / 4 || Math.abs(angle) > 3 * Math.PI / 4)) {
                // Í∞ÄÎ°ú
                dr = 0;
                dc = dx > 0 ? 1 : -1;
            } else if (Math.abs(dy) > Math.abs(dx) && (Math.abs(angle) > Math.PI / 4 && Math.abs(angle) < 3 * Math.PI / 4)) {
                // ÏÑ∏Î°ú
                dr = dy > 0 ? 1 : -1;
                dc = 0;
            } else if (dx > 0 && dy > 0 && Math.abs(dx - dy) < threshold) {
                // Ïö∞Ìïò ÎåÄÍ∞ÅÏÑ†
                dr = 1;
                dc = 1;
            } else if (dx < 0 && dy > 0 && Math.abs(dx + dy) < threshold) {
                // Ï¢åÌïò ÎåÄÍ∞ÅÏÑ†
                dr = 1;
                dc = -1;
            } else {
                // Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÎìúÎûòÍ∑∏, Ï∑®ÏÜå
                isEggSkillMode = false;
                updateEggSkillButton();
                startTimer();
                log(`ü™∂ ÏïåÍπåÍ∏∞ Î∞©Ìñ• ÏÑ†ÌÉù Ïã§Ìå®. Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.`, 'error');
                return;
            }

            // Ïï†ÎãàÎ©îÏù¥ÏÖò: Îèå Ïù¥Îèô Î∞è ÏÉÅÎåÄ Îèå Ï†úÍ±∞
            const stonesToRemove = [];
            let row = selectedRow;
            let col = selectedCol;
            while (row >= 0 && row < boardSize && col >= 0 && col < boardSize) {
                if (board[row][col] === (currentPlayer === 1 ? 2 : 1)) {
                    stonesToRemove.push({ row, col });
                }
                row += dr;
                col += dc;
            }

            let animationProgress = 0;
            const animationDuration = 500; // 500ms
            function animate() {
                drawBoard();
                const t = animationProgress / animationDuration;
                const opacity = 1 - t; // ÌéòÏù¥ÎìúÏïÑÏõÉ
                const moveDistance = t * 5 * cellSize; // 5Ïπ∏ Ïù¥Îèô
                const moveX = cellSize / 2 + selectedCol * cellSize + moveDistance * dc;
                const moveY = cellSize / 2 + selectedRow * cellSize + moveDistance * dr;
                ctx.fillStyle = currentPlayer === 1 ? '#000' : '#fff';
                drawStone(selectedRow, selectedCol, opacity);
                ctx.beginPath();
                ctx.arc(moveX, moveY, cellSize / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();

                stonesToRemove.forEach(({ row, col }) => {
                    ctx.fillStyle = currentPlayer === 1 ? '#fff' : '#000';
                    drawStone(row, col, opacity);
                });

                animationProgress += 16; // ÏïΩ 60fps
                if (animationProgress < animationDuration) {
                    animationFrameId = requestAnimationFrame(animate);
                } else {
                    // Ïï†ÎãàÎ©îÏù¥ÏÖò Ï¢ÖÎ£å
                    cancelAnimationFrame(animationFrameId);
                    board[selectedRow][selectedCol] = 0; // ÏÑ†ÌÉùÌïú Îèå Ï†úÍ±∞
                    stonesToRemove.forEach(({ row, col }) => {
                        board[row][col] = 0;
                        log(`ü™∂ ÏÉÅÎåÄ Îèå (${row + 1}, ${col + 1}) Ï†úÍ±∞!`, 'warning');
                    });
                    drawBoard();
                    log(`ü™∂ ${currentPlayer === 1 ? player1Name : player2Name}ÎãòÏù¥ ÏïåÍπåÍ∏∞ Ïä§ÌÇ¨ ÏÇ¨Ïö©!`, 'warning');
                    if (currentPlayer === 1) player1EggSkill--;
                    else player2EggSkill--;
                    isEggSkillMode = false;
                    updateEggSkillButton();
                    currentPlayer = currentPlayer === 1 ? 2 : 1;
                    updateTurnInfo();
                    updateSkillButton();
                    startTimer();
                }
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        function handleCanvasClick(event) {
            if (!gameActive || isEggSkillMode) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row < 0 || row >= boardSize || col < 0 || col >= boardSize) return;
            if (board[row][col] !== 0) return;

            board[row][col] = currentPlayer;
            moveCount++;
            drawBoard();
            log(`${currentPlayer === 1 ? player1Name : player2Name}ÎãòÏù¥ (${row + 1}, ${col + 1})Ïóê Îèå Î∞∞Ïπò`, 'info');

            removeRandomOpponentStone();

            if (checkWin(row, col)) {
                const winner = currentPlayer === 1 ? player1Name : player2Name;
                showModal(`${winner}Îãò ÏäπÎ¶¨!`, 'success', true);
                clearInterval(timerId);
                gameActive = false;
                return;
            }

            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
        }

        function checkWin(row, col) {
            const directions = [
                [0, 1], [1, 0], [1, 1], [1, -1] // Í∞ÄÎ°ú, ÏÑ∏Î°ú, ÎåÄÍ∞ÅÏÑ†(Ïö∞Ìïò, Ï¢åÌïò)
            ];
            const player = board[row][col];

            for (const [dr, dc] of directions) {
                let count = 1;
                for (let dir = -1; dir <= 1; dir += 2) {
                    for (let i = 1; i <= 4; i++) {
                        const newRow = row + dr * i * dir;
                        const newCol = col + dc * i * dir;
                        if (
                            newRow >= 0 && newRow < boardSize &&
                            newCol >= 0 && newCol < boardSize &&
                            board[newRow][newCol] === player
                        ) {
                            count++;
                        } else {
                            break;
                        }
                    }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function updateTurnInfo() {
            const turnInfo = document.getElementById('turn-info');
            const playerName = currentPlayer === 1 ? player1Name : player2Name;
            const stone = currentPlayer === 1 ? '‚óè ÌùëÎèå' : '‚óã Î∞±Îèå';
            turnInfo.innerHTML = `ÌÑ¥: <span>${playerName}</span> (${stone})`;
        }

        function showModal(message, type = 'error', showRestart = false) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <h2 style="color: ${type === 'success' ? '#27ae60' : '#e74c3c'}">${message}</h2>
                    <button onclick="closeModal()">ÌôïÏù∏</button>
                    ${showRestart ? '<button onclick="restartGame()">Îã§Ïãú ÏãúÏûë</button>' : ''}
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeModal() {
            const modal = document.querySelector('.modal');
            if (modal) modal.remove();
        }

        function restartGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            board = Array(boardSize).fill().map(() => Array(boardSize).fill(0));
            currentPlayer = 1;
            gameActive = true;
            moveCount = 0;
            player1MeteorSkill = 2;
            player2MeteorSkill = 2;
            player1EggSkill = 3;
            player2EggSkill = 3;
            isEggSkillMode = false;
            selectedRow = -1;
            selectedCol = -1;
            isDragging = false;
            logs = [];
            log('üéâ ÏÉà Í≤åÏûÑ ÏãúÏûë!', 'info');
            drawBoard();
            updateTurnInfo();
            updateSkillButton();
            updateEggSkillButton();
            startTimer();
            closeModal();
        }

        function log(message, type = 'info') {
            logs.push({ message, type });
            if (logs.length > 10) logs.shift();
            const logContainer = document.getElementById('game-log');
            logContainer.innerHTML = logs.map(log => `
                <div class="log-entry log-${log.type}">${log.message}</div>
            `).join('');
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
    </script>
</body>
</html>
